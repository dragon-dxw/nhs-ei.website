# Application Structure

TOC

1. [Files & Folders](#ff)
2. [Wagtail App Guide](#wag)
3. [Importer Guide](#ig)
4. [Deployment Guide](#dg)

# [Files and Folders](#ff)

```
project
└───cms
│   │   urls.py (url configuration)
│   │   wsgi.py (server config)
│   │
│   └───[module name] e.g. publications
│       └───migrations
│       │   ... wagtail auto generated
│       │
│       └───templates
│       │   ... html templates related to this module
│       │
│       └───templatetags
│       │   ... functions that can be used from templates
│       │
│       └───settings
│       │   ... config files for development/production etc
│       └───static
│       │   ... compiled static files
│       └───templates
│       │   ... site wide inherited templates in here, that don't relate to a specific module
│       admin.py (django admin config not used in Wagtail (=> wagtail_hooks.py)
│       apps.py (module config, auto generated)
│       models.py (models used in the module)
│       tests.py (tests for the module)
│       views.py (views for the module, although wagtail Page model generally replaces this)
│       wagtail_hooks.py (wagtail admin configuration)
│
│
└───importer
│   └───bin
│       │   ... file/s of commands
│   └───log
│   └───management
│   └───static
│   └───templates
│       └───migrations
│       │   ... auto generated by wagtail/django
│       │
│       └───templates
│       │   ... not used on the frontend but can be used by developers
│       │
│       admin.py (django admin config not used in Wagtail (=> wagtail_hooks.py)
│       apps.py (module config, auto generated)
│       ancestry.py (utility classes for importer)
│       documents_list_builder.py (function that are run at import stages)
│       import_*.py (django management commands that perform importing from scrapy API)
│       import_cls.py (a helper class used by import_*.py scripts)
│       models.py (unused)
│       *.ipynb (not required, used for experimentation, they are ipython notebook files)
│       richtextbuilder.py (used when importing to change json/fields into Wagtail streamfields dictionary objects)
│       test.py (not implemented yet)
│       url.py (module specific url config)
│       views.py (module specific views, only used as a developer reference)
│       wagtail_hook.py (no longer used)
│
└───packages
│   ... frontend assets (https://github.com/nhsuk/nhsuk-frontend)
│
README.md
poetry.lock
pyproject.toml
manage.py
```

---

# [Wagtail App Guide](#wag)

The folder and files example of atlas_case_studies above is generally repeated across all apps that have frontend views. All apps have similar code/layout and function in a similar way.

`Management Commands` [Official Docs](https://docs.djangoproject.com/en/3.1/howto/custom-management-commands/)

- Generally there is one management command for each app that deals with deleting all the records from it's model/s but they are not found in the app modules but in the importer module [Importer Guide](#ig)

`admin.py` [Official Docs](https://docs.djangoproject.com/en/3.1/ref/contrib/admin/)

- Is used to configure django-admin for each app. [Official Docs](https://docs.djangoproject.com/en/3.1/ref/contrib/admin/). Wagtail provides it's own admin via builtin class used or using wagtail_hooks.py for none Page models

`models.py` [Official Wagtail Docs](https://docs.wagtail.io/en/v2.10.2/topics/pages.html)

- Is where data models are defined, generally for Page models. Wagtail Page models also provide most template rendering methods

`wagtail_hooks.py` [Official Wagtail Docs](https://docs.wagtail.io/en/v2.10.2/reference/contrib/modeladmin/index.html)

- Wagtail hooks can be used in many different ways. The official docs link here has more detail

`views.py` While views are generally used in django to render html templates wagtail models provide that function built in for most use cases

---

# [Importer Guide](#ig)

### /bin

- Just some assets that are used for initial setup

### /log

- The import process logs errors here

### /management/commands

- Theres a lot of individual commands here. There are just two commands that are run from the command line. `python manage.py delete_all` and `python manage.py runimport`. These two commands in turn call the other commands in this folder. The other commands can be run separately during development.

---

# [Deployment Guide](#dg)

While the app can be developed using a virtual env or docker-compose, deploy to production needs Docker. The github repo runs github actions to deploy the code to the Azure platform.

See [github actions] in the repo (https://github.com/rkhleics/nhs-ei.website/actions) for more information

# Running management commands on the deployed app

The app is intended to run in a containerised environment, specifically the [Azure Kubernetes Service]().

To run commands on the running application pods you can connect using Kubectl

## Prerequisites

- Kubectl installed [https://kubernetes.io/docs/tasks/tools/install-kubectl/](https://kubernetes.io/docs/tasks/tools/install-kubectl/)
- The Azure command line client installed [https://docs.microsoft.com/en-us/cli/azure/install-azure-cli](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli)
- A user account in the Azure tenancy with permissions to administer the AKS cluster. For this you would need to speak with a member of the NHS England team.
- The resource group and name of the cluster you wish to connect to.
- (optional but recommended) the name of the namespace / deployment used when installing
  the app to the cluster.

## Setup

1. [Sign in](https://docs.microsoft.com/en-us/cli/azure/authenticate-azure-cli) to Azure using the command line client (`az`)
2. Get the Kubernetes secret using the Azure command line client:

   ```
   $ az aks get-credentials --name MyManagedCluster --resource-group MyResourceGroup
   ```

   This should update your Kubernetes configuration with the required credentials.
   More information is available in the [Azure documentation](https://docs.microsoft.com/en-us/cli/azure/aks?view=azure-cli-latest#az_aks_get_credentials).

## Connecting to a pod

You should now be able to [get a shell on a running container](https://kubernetes.io/docs/tasks/debug-application-cluster/get-shell-running-container/).
The Kubernetes [documentation](https://kubernetes.io/docs/home/) is comprehensive, below we'll just cover the basic steps for getting access to a pod.

### Choosing a pod

By running `$ kubectl get po --all-namespaces` you should be shown a list of all running
pods, along with their namespaces. Namespaces should hopefully be logically named, ie `default` or `production` for the live app, `staging` or `uat` for non-live environments.

For the next step you will need the name of the pod and the namespace it is in.

### Connecting to the chosen pod

To connect to the chosen pod run `$ kubectl exec -it [POD NAME] --namespace [POD NAMESPACE] -- bash`

This will connect you to a bash shell running on that pod, from there you can run
management commands.

For those not familiar with containerised apps: containers should be considered stateless.
This means if you change or create a file on a pod, do not expect it to survive if the
pod restarts, or be available on other pods.

Once finished, simply exit the shell.
